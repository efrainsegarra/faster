//
// code generated by the command : fasterac_reader_code ../data/cf4_only/bkg_10h_0001.fast reader
//
//

/*
 *  Faster reader demo code
 *  How to handle faster data specific fields
 */

#include <stdio.h>
#include <string.h>

#include "fasterac/fasterac.h"       // mandatory for any data type
#include "fasterac/utils.h"          // some specific tools
#include "fasterac/qt2t.h"           // qt2T, qt2T_counter
#include "fasterac/group.h"          // group

#include "TFile.h"
#include "TTree.h"
#include <iostream>

using namespace std;

const int Max_mult 	= 50;
int 		Event = 0;
unsigned int  	Mult;
unsigned int  	Delta_t;
int	 	Charge[Max_mult];
unsigned int	Width[Max_mult];
unsigned int	Amp[Max_mult];
unsigned int	Rise_time[Max_mult];
int		Baseline[Max_mult];
int		Saturated[Max_mult];
double		Start_time;
unsigned short	Channel[Max_mult];
double		Time[Max_mult];
bool		New_event = false;
bool		Fill_ROOT = false;



void data_disp (faster_data_p data, int n, int tab);
//

//
//  GROUP
//
void grp_disp (faster_data_p data, int tab) {
	int                    group_n = 0;
	faster_data_p          group_data;
	unsigned short         lsize        = faster_data_load_size     (data);                // size of all the data inside the group
	void*                  group_buffer = faster_data_load_p        (data);                // get group data (a pointer)
	faster_buffer_reader_p group_reader = faster_buffer_reader_open (group_buffer, lsize); // create a reader for that group
	//printf ("\n");
	while ((group_data = faster_buffer_reader_next (group_reader)) != NULL) {              // read each data of the group
		group_n += 1;                                                                       // count nb of data
		data_disp (group_data, group_n, tab);                                               // display the data
	}
	faster_buffer_reader_close (group_reader);                                             // close the reader
											       //
											       //  How to copy the group
											       //
											       //  #include <string.h>
											       //
											       //  void           buffer [4096];                   // get enough memory
											       //  unsigned short buffer_size;
											       //
											       //  buffer_size = faster_data_load (data, buffer);  // buffer_size < 4096
											       //
}

//
//  GROUP COUNTER
//
void grp_count_disp (faster_data_p data, int tab) {
	//cout << "\n3\n";
	group_counter count;
	unsigned int  mult;
	unsigned int  delta_t;
	faster_data_load (data, &count);                  // get the data
	mult    = count.mult;                             // multiplicity of the group
	delta_t = count.delta_t;                          // maximum delta time in the group
	//printf ("mult=%d  delta_t=%d\n", mult, delta_t);

	Mult = mult;
	Delta_t = delta_t;
	New_event = false; // we are done reading the event
	
	// Now fill the root tree
	Fill_ROOT = true;
}

//
// QT2T
//
void qt2t_disp (faster_data_p data, int tab, int n) {
	//cout << "\n2\n";
	qt2t         qtt;
	int          charge;
	int          q_base;
	int          saturated;
	unsigned int width_ns;
	unsigned int max_amp;
	unsigned int max_pos;
	faster_data_load (data, &qtt);                     // get the data
	charge    = qtt.q;                                 // (au)
	q_base    = qtt.q_baseline;                        // (au) charge before threshold
	saturated = qtt.saturated;
	width_ns  = qtt.w * 2;                             // (ns) 2ns per sample
	max_amp   = qtt.a_max;                             // (au)
	max_pos   = qtt.t_max * 2;                         // (ns)
	
	Charge[n-1] 	= charge;
	Width[n-1] 	= width_ns;
	Amp[n-1] 	= max_amp;
	Rise_time[n-1] 	= max_pos;
	Baseline[n-1] 	= q_base;
	Saturated[n-1]	= saturated;
	

	//printf ("Q=%d  width=%dns  max_ampl=%d  max_pos=%dns  q_baseline=%d", charge, width_ns, max_amp, max_pos, q_base);
	//if (saturated) printf (" saturated");
	//printf ("\n");
}

//
//  QT2T COUNTER
//
void qt2t_count_disp (faster_data_p data, int tab) {
	qt2t_counter count;
	unsigned int trig;
	unsigned int calc;
	unsigned int sent;
	faster_data_load (data, &count);
	trig = count.trig;
	calc = count.calc;
	sent = count.sent;
	//printf ("trig=%d  calc=%d  sent=%d\n", trig, calc, sent);
}

//
//  ANY DATA
//
void data_disp (faster_data_p data, int n, int tab) {
	int  i;
	unsigned short label = faster_data_label      (data);               //  label of the data
	long double    clock = faster_data_clock_sec  (data);               //  time stamp of the data (ns)
	unsigned char  alias = faster_data_type_alias (data);               //  type of the data
									    
	if( alias == GROUP_TYPE_ALIAS && New_event == false){ // this is a flag for a new grouping
		New_event = true;
		// Clear out all old information
		Mult = 0;
		Delta_t = 0;
		memset(Charge,0,sizeof(Charge));
		memset(Width,0,sizeof(Width));
		memset(Amp,0,sizeof(Amp));
		memset(Rise_time,0,sizeof(Rise_time));
		memset(Baseline,0,sizeof(Baseline));
		memset(Saturated,0,sizeof(Saturated));
		Start_time = 0;
		memset(Channel,0,sizeof(Channel));
		memset(Time,0,sizeof(Time));
	
		//cout << "\n0\n";
		// Start information for new event
		Start_time = clock;
	}
	if( alias == QT2T_TYPE_ALIAS && New_event == true ){
		Channel[n-1] = label;
		Time[n-1] = clock;
		//cout << "\n1\n";
	}


	//for (i=0; i<tab; i++) printf ("   ");
	//printf ("%d %d %s %.9Lfs  ", n, label, type_name (alias), clock);   //  display label, type name, time stamp for all data
	if (0)  {} // what else ?                                           //  display specific data parts depending of the data type
	else if (alias == GROUP_TYPE_ALIAS)              grp_disp            (data, tab+1);
	else if (alias == GROUP_COUNTER_TYPE_ALIAS)      grp_count_disp      (data, tab+1);
	else if (alias == QT2T_TYPE_ALIAS)               qt2t_disp           (data, tab+1,n);
	else if (alias == QT2T_COUNTER_TYPE_ALIAS)       qt2t_count_disp     (data, tab+1);
	//else printf ("\n");


}

//
//  MAIN
//
int main (int argc, char** argv) {

	if (argc < 3) {                                                //  command args
		printf ("usage : \n");
		printf ("        %s \t output_file.root \t files*.fast \n", argv[0]);
		printf ("\n");
		return EXIT_SUCCESS;
	}

	faster_file_reader_p  reader;      //  data file reader
	faster_data_p         data;        //  data pointer
	int                   n    = 0;    //  data num
	int                   tab  = 0;    //  deco
					   
	// Create output root file for writing data
	TFile * outfile = new TFile(argv[1],"RECREATE");
	TTree * outtree = new TTree("faster","Skim of faster file");
	// TODO: fix issue with unsigned int to branch...
	outtree->Branch("event", 	&Event,		"event/I"		);
	outtree->Branch("mult",		&Mult,		"mult/i"		);
	outtree->Branch("delta_t",	&Delta_t,	"delta_t/i"		);
	outtree->Branch("start_t",	&Start_time,	"start_t/D"		);
	outtree->Branch("channel",	Channel,	"channel[mult]/I"	);
	outtree->Branch("time",		Time,		"time[mult]/D"		);
	outtree->Branch("q",		Charge,		"q[mult]/I"		);
	outtree->Branch("a",		Amp,		"a[mult]/i"		);
	outtree->Branch("rise_t",	Rise_time,	"rise_t[mult]/i"	);
	outtree->Branch("width_t",	Width,		"width_t[mult]/i"	);
	outtree->Branch("q_base",	Baseline,	"q_base[mult]/I"	);
	outtree->Branch("saturated",	Saturated,	"saturated[mult]/I"	);

	for( int faster_file = 2; faster_file < argc; faster_file++ ){
		reader = faster_file_reader_open (argv[faster_file]);                    //  open the reader
		if (reader == NULL) {
			printf ("error opening file %s\n", argv[faster_file]);
			return EXIT_FAILURE;
		}


		while ((data = faster_file_reader_next (reader)) != NULL) {    //  read each data one by one
			//printf ("\n");
			data_disp (data, n, tab);                                   //  display each
			if( Fill_ROOT ){
				outtree->Fill();
				Event += 1;
				Fill_ROOT = false;
			}
			n = n + 1;                                                  //  see above : common part 'data_disp' + specific part = f (type)
		}
		faster_file_reader_close (reader);                             //  close the reader
	}



	outfile->cd();
	outtree->Write();
	outfile->Close();

	return EXIT_SUCCESS;
}

